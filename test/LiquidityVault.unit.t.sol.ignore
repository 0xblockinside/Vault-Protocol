// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.17;

import {ILiquidityVault} from "../src/interfaces/ILiquidityVault.sol";
import "src/LiquidityVault.sol";
import "forge-std/Test.sol";
import {IV3SwapRouter} from "shared/src/libraries/UniswapLiquidity.sol";
import {TestERC20} from "./tokens/TestERC20.sol";
import {TestTaxedERC20} from "./tokens/TestTaxedERC20.sol";
import {IUniswapV2Pair} from "v2-core/interfaces/IUniswapV2Pair.sol";
import {IUniswapV3Pool} from "v3-core/contracts/interfaces/IUniswapV3Pool.sol";
import {IMintableERC20} from "./interfaces/IMintableERC20.sol";
import {NoPermit} from "shared/src/structs/Permit.sol";

library SnapshotLogDecoder {
    function decode(Vm.Log memory log, address pool) internal returns (ILiquidityVault.LiquidityPoolSnapshot memory snapshot) {
        snapshot.pool = pool;
        if (log.topics[0] == keccak256("Minted(uint256,address,address,uint88,uint256,bool,bytes)")) {
            snapshot.amountIn0 = uint256(log.topics[7]);
            snapshot.amountIn1 = uint256(log.topics[8]);
            snapshot.liquidity = uint256(log.topics[5]);
        }
        else if (log.topics[0] == keccak256("Collected(uint256,uint256,uint256,bytes)")) {
            // decode amount0, amount1, liquidity from bytes
            snapshot.amountIn0 = uint256(log.topics[4]);
            snapshot.amountIn1 = uint256(log.topics[5]);
            snapshot.liquidity = uint256(log.topics[6]);
        }
        else if (log.topics[0] == keccak256("Increased(uint256,uint256,uint256,bytes)")) {
            snapshot.amountIn0 = uint256(log.topics[4]);
            snapshot.amountIn1 = uint256(log.topics[5]);
            snapshot.liquidity = uint256(log.topics[6]);
        }
    }
}

library FixedPoint {
    function addLeadingZeros(string memory numberStr, uint256 totalLength) public pure returns (string memory) {
        string memory zeros = "";
        for(uint i = 0; i < totalLength - bytes(numberStr).length; i++) {
            zeros = string(abi.encodePacked(zeros, "0"));
        }
        return string(abi.encodePacked(zeros, numberStr));
    }

    function toFPString(uint256 n, uint8 decimals, Vm vm) internal returns (string memory) {
        uint integerPart = n / 10 ** decimals;
        uint decimalPart = n % 10 ** decimals;
        return string(abi.encodePacked(vm.toString(integerPart), ".", addLeadingZeros(vm.toString(decimalPart), decimals)));
    }
}

contract LiquidityVaultUnitTests is Test {
    using FixedPoint for uint;

    modifier useActor() {
        startHoax(msg.sender);
        _;
        vm.stopPrank();
    }

    LiquidityVault lVault;

    function setUp() external {
        lVault = new LiquidityVault();
    }

    receive() external payable { }

    function test_COD_specific1() external {
        address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
        
        TestERC20 tokenBV3;
        do {
            tokenBV3 = new TestERC20();
        }
        while (address(tokenBV3) < weth);

        uint tokenASupply = 639936000000000000000;
        uint tokenBSupplyV3 = 222222222000000000000000000; //tokenAV2.totalSupply();

        tokenBV3.approve(address(lVault), tokenBSupplyV3);

        uint24 fee = UniswapLiquidity.FEE_TIERS()[2];//[_bound(feeSeed, 0, 2)];
        (int24 lowerTick, int24 upperTick) = UniswapLiquidity.maxTickBoundary(fee);
        lVault.mint{ value: tokenASupply }(ILiquidityVault.MintConfig({
            version: UniswapLiquidity.Version.V3,
            tokenA: address(0),
            tokenB: address(tokenBV3),
            permitA: NoPermit(),
            permitB: NoPermit(),
            amountA: tokenASupply,
            amountB: tokenBSupplyV3,
            requiredA: tokenASupply,
            requiredB: 0,
            fee: fee,
            tickLower: lowerTick,
            tickUpper: upperTick,
            lockDuration: 8 * 30 days
        }));
        // assertEq(false, true);
        // assertEq(lVault.balanceOf(msg.sender), startBal + 2);    
    }

    function test_COD_specific() external {
        TestERC20 tokenAV3 = new TestERC20();
        uint tokenBSupply = 639936000000000000000;
        uint tokenASupplyV3 = 222222222000000000000000000; //tokenAV2.totalSupply();

        tokenAV3.approve(address(lVault), tokenASupplyV3);

        uint24 fee = UniswapLiquidity.FEE_TIERS()[2];//[_bound(feeSeed, 0, 2)];
        (int24 lowerTick, int24 upperTick) = UniswapLiquidity.maxTickBoundary(fee);
        lVault.mint{ value: tokenBSupply }(ILiquidityVault.MintConfig({
            version: UniswapLiquidity.Version.V3,
            tokenA: address(tokenAV3),
            tokenB: address(0),
            permitA: NoPermit(),
            permitB: NoPermit(),
            amountA: tokenASupplyV3,
            amountB: tokenBSupply,
            requiredA: 0,
            requiredB: tokenBSupply, 
            fee: fee,
            tickLower: lowerTick,
            tickUpper: upperTick,
            lockDuration: 8 * 30 days
        }));
        assertEq(false, true);
        // assertEq(lVault.balanceOf(msg.sender), startBal + 2);    
    }
    
    function test_tokenETHMint(uint tokenBSeed, uint feeSeed, uint32 lockTime) useActor external {
        vm.skip(true);
        uint startBal = lVault.balanceOf(msg.sender);
        TestERC20 tokenAV2 = new TestERC20();

        uint tokenASupplyV2 = tokenAV2.totalSupply();
        uint tokenBSupply = _bound(tokenBSeed, 0.1 ether, 5 ether);

        tokenAV2.approve(address(lVault), tokenASupplyV2);

        lVault.mint{ value: tokenBSupply }(ILiquidityVault.MintConfig({
            version: UniswapLiquidity.Version.V2,
            tokenA: address(tokenAV2),
            tokenB: address(0), // WE could do a native eth constant for this
            permitA: NoPermit(),
            permitB: NoPermit(),
            amountA: tokenASupplyV2,
            amountB: tokenBSupply,
            requiredA: 0,
            requiredB: 0, 
            fee: 0,
            tickLower: 0,
            tickUpper: 0,
            lockDuration: lockTime
        }));

        assertEq(lVault.balanceOf(msg.sender), startBal + 1);

        TestERC20 tokenAV3 = new TestERC20();
        uint tokenASupplyV3 = tokenAV2.totalSupply();

        tokenAV3.approve(address(lVault), tokenASupplyV3);

        uint24 fee = UniswapLiquidity.FEE_TIERS()[_bound(feeSeed, 0, 2)];
        (int24 lowerTick, int24 upperTick) = UniswapLiquidity.maxTickBoundary(fee);
        lVault.mint{ value: tokenBSupply }(ILiquidityVault.MintConfig({
            version: UniswapLiquidity.Version.V3,
            tokenA: address(tokenAV3),
            tokenB: address(0),
            permitA: NoPermit(),
            permitB: NoPermit(),
            amountA: tokenASupplyV3,
            amountB: tokenBSupply,
            requiredA: 0,
            requiredB: 0, 
            fee: fee,
            tickLower: lowerTick,
            tickUpper: upperTick,
            lockDuration: lockTime
        }));

        assertEq(lVault.balanceOf(msg.sender), startBal + 2);
    }

    function test_tokenTokenMint(uint32 lockTime, uint feeSeed) useActor external {
        vm.skip(true);
        uint startBal = lVault.balanceOf(msg.sender);
        TestERC20 tokenAV2 = new TestERC20();
        TestERC20 tokenBV2 = new TestERC20();

        uint tokenASupplyV2 = tokenAV2.totalSupply();
        uint tokenBSupplyV2 = tokenBV2.totalSupply();

        tokenAV2.approve(address(lVault), tokenASupplyV2);
        tokenBV2.approve(address(lVault), tokenBSupplyV2);

        lVault.mint(ILiquidityVault.MintConfig({
            version: UniswapLiquidity.Version.V2,
            tokenA: address(tokenAV2),
            tokenB: address(tokenBV2),
            permitA: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            permitB: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            amountA: tokenASupplyV2,
            amountB: tokenBSupplyV2,
            requiredA: 0,
            requiredB: 0, 
            fee: 0,
            tickLower: 0,
            tickUpper: 0,
            lockDuration: lockTime
        }));

        assertEq(lVault.balanceOf(msg.sender), startBal + 1);

        TestERC20 tokenAV3 = new TestERC20();
        TestERC20 tokenBV3 = new TestERC20();

        uint tokenASupplyV3 = tokenAV3.totalSupply();
        uint tokenBSupplyV3 = tokenBV3.totalSupply();

        tokenAV3.approve(address(lVault), tokenASupplyV2);
        tokenBV3.approve(address(lVault), tokenBSupplyV3);

        uint24 fee = UniswapLiquidity.FEE_TIERS()[_bound(feeSeed, 0, 2)];
        (int24 lowerTick, int24 upperTick) = UniswapLiquidity.maxTickBoundary(fee);
        lVault.mint(ILiquidityVault.MintConfig({
            version: UniswapLiquidity.Version.V3,
            tokenA: address(tokenAV3),
            tokenB: address(tokenBV3),
            permitA: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            permitB: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            amountA: tokenASupplyV3,
            amountB: tokenBSupplyV3,
            requiredA: 0,
            requiredB: 0, 
            fee: fee,
            tickLower: lowerTick,
            tickUpper: upperTick,
            lockDuration: lockTime
        }));

        assertEq(lVault.balanceOf(msg.sender), startBal + 2);
    }

    function test_taxedTokenETHMint(uint tokenBSeed, uint feeSeed, uint32 lockTime) useActor external {
        vm.skip(true);
        uint startBal = lVault.balanceOf(msg.sender);
        TestTaxedERC20 tokenAV2 = new TestTaxedERC20();

        uint tokenASupplyV2 = tokenAV2.totalSupply();
        uint tokenBSupply = _bound(tokenBSeed, 10 ** 17, 5 * 10 ** 18);

        tokenAV2.approve(address(lVault), tokenASupplyV2);

        lVault.mint{ value: tokenBSupply }(ILiquidityVault.MintConfig({
            version: UniswapLiquidity.Version.V2,
            tokenA: address(tokenAV2),
            tokenB: address(0),
            permitA: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            permitB: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            amountA: tokenASupplyV2,
            amountB: tokenBSupply,
            requiredA: 0,
            requiredB: 0, 
            fee: 0,
            tickLower: 0,
            tickUpper: 0,
            lockDuration: lockTime
        }));

        assertEq(lVault.balanceOf(msg.sender), startBal + 1);

        TestERC20 tokenAV3 = new TestERC20();
        uint tokenASupplyV3 = tokenAV3.totalSupply();

        tokenAV3.approve(address(lVault), tokenASupplyV2);

        uint24 fee = UniswapLiquidity.FEE_TIERS()[_bound(feeSeed, 0, 2)];
        (int24 lowerTick, int24 upperTick) = UniswapLiquidity.maxTickBoundary(fee);
        lVault.mint{ value: tokenBSupply }(ILiquidityVault.MintConfig({
            version: UniswapLiquidity.Version.V3,
            tokenA: address(tokenAV3),
            tokenB: address(0),
            permitA: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            permitB: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            amountA: tokenASupplyV3,
            amountB: tokenBSupply,
            requiredA: 0,
            requiredB: 0, 
            fee: fee,
            tickLower: lowerTick,
            tickUpper: upperTick,
            lockDuration: lockTime
        }));

        assertEq(lVault.balanceOf(msg.sender), startBal + 2);
    }

    function test_taxedTokenTaxedTokenMint(uint feeSeed, uint32 lockTime) useActor external {
        vm.skip(true);
        uint startBal = lVault.balanceOf(msg.sender);
        TestTaxedERC20 tokenAV2 = new TestTaxedERC20();
        TestTaxedERC20 tokenBV2 = new TestTaxedERC20();

        uint tokenASupplyV2 = tokenAV2.totalSupply();
        uint tokenBSupplyV2 = tokenBV2.totalSupply();

        tokenAV2.approve(address(lVault), tokenASupplyV2);
        tokenBV2.approve(address(lVault), tokenASupplyV2);

        lVault.mint(ILiquidityVault.MintConfig({
            version: UniswapLiquidity.Version.V2,
            tokenA: address(tokenAV2),
            tokenB: address(tokenBV2),
            permitA: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            permitB: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            amountA: tokenASupplyV2,
            amountB: tokenBSupplyV2,
            requiredA: 0,
            requiredB: 0, 
            fee: 0,
            tickLower: 0,
            tickUpper: 0,
            lockDuration: lockTime
        }));

        assertEq(lVault.balanceOf(msg.sender), startBal + 1);

        TestTaxedERC20 tokenAV3 = new TestTaxedERC20();
        TestTaxedERC20 tokenBV3 = new TestTaxedERC20();

        uint tokenASupplyV3 = tokenAV3.totalSupply();
        uint tokenBSupplyV3 = tokenBV3.totalSupply();

        tokenAV3.approve(address(lVault), tokenASupplyV2);
        tokenBV3.approve(address(lVault), tokenBSupplyV3);

        uint24 fee = UniswapLiquidity.FEE_TIERS()[_bound(feeSeed, 0, 2)];
        (int24 lowerTick, int24 upperTick) = UniswapLiquidity.maxTickBoundary(fee);
        lVault.mint(ILiquidityVault.MintConfig({
            version: UniswapLiquidity.Version.V3,
            tokenA: address(tokenAV3),
            tokenB: address(tokenBV3),
            permitA: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            permitB: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            amountA: tokenASupplyV3,
            amountB: tokenBSupplyV3,
            requiredA: 0,
            requiredB: 0, 
            fee: fee,
            tickLower: lowerTick,
            tickUpper: upperTick,
            lockDuration: lockTime
        }));

        assertEq(lVault.balanceOf(msg.sender), startBal + 2);
    }

    function test_tokenETHRedeem(uint tokenBSeed, uint feeSeed, uint32 lockTime) useActor external {
        vm.skip(true);
        vm.recordLogs();
        TestERC20 tokenAV2 = new TestERC20();

        uint tokenASupplyV2 = tokenAV2.totalSupply();
        uint tokenBSupply = _bound(tokenBSeed, 10 ** 17, 5 * 10 ** 18);

        tokenAV2.approve(address(lVault), tokenASupplyV2);

        lVault.mint{ value: tokenBSupply }(ILiquidityVault.MintConfig({
            version: UniswapLiquidity.Version.V2,
            tokenA: address(tokenAV2),
            tokenB: address(0),
            permitA: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            permitB: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            amountA: tokenASupplyV2,
            amountB: tokenBSupply,
            requiredA: 0,
            requiredB: 0, 
            fee: 0,
            tickLower: 0,
            tickUpper: 0,
            lockDuration: lockTime
        }));

        Vm.Log[] memory logs = vm.getRecordedLogs();
        Vm.Log memory transferLog = logs[logs.length - 1];
        Vm.Log memory v2ProofLog = logs[logs.length - 2];

        uint v2ID = uint(transferLog.topics[3]);

        ILiquidityVault.LiquidityPoolSnapshot memory v2Proof = ILiquidityVault.LiquidityPoolSnapshot({
            pool: UniswapLiquidity.V2_FACTORY.getPair(address(tokenAV2), UniswapLiquidity.SWAP_ROUTER.WETH9()),
            initAmount0: uint(v2ProofLog.topics[2]),
            initAmount1: uint(v2ProofLog.topics[3]),
            liquidity: uint(v2ProofLog.topics[1])
        });


        vm.expectRevert();
        lVault.redeem(v2ID, v2Proof);

        
        skip(lockTime);
        vm.expectRevert();
        lVault.redeem(v2ID, v2Proof);

        skip(1);
        lVault.redeem(v2ID, v2Proof);

        // V3

        TestERC20 tokenAV3 = new TestERC20();
        uint tokenASupplyV3 = tokenAV3.totalSupply();

        tokenAV3.approve(address(lVault), tokenASupplyV3);

        uint24 fee = UniswapLiquidity.FEE_TIERS()[_bound(feeSeed, 0, 2)];
        (int24 lowerTick, int24 upperTick) = UniswapLiquidity.maxTickBoundary(fee);
        lVault.mint{ value: tokenBSupply }(ILiquidityVault.MintConfig({
            version: UniswapLiquidity.Version.V3,
            tokenA: address(tokenAV3),
            tokenB: address(0),
            permitA: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            permitB: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            amountA: tokenASupplyV3,
            amountB: tokenBSupply,
            requiredA: 0,
            requiredB: 0, 
            fee: fee,
            tickLower: lowerTick,
            tickUpper: upperTick,
            lockDuration: lockTime
        }));


        logs = vm.getRecordedLogs();
        transferLog = logs[logs.length - 1];

        uint v3ID = uint(transferLog.topics[3]);


        v2Proof = ILiquidityVault.LiquidityPoolSnapshot(address(0), 0, 0, 0);
        
        vm.expectRevert();
        lVault.redeem(v3ID, v2Proof);

        skip(lockTime);
        vm.expectRevert();
        lVault.redeem(v3ID, v2Proof);

        skip(1);
        lVault.redeem(v3ID, v2Proof);
    }

    function swap(address poolAddr, UniswapLiquidity.Version version, uint amountSeed, uint seed) internal {
        vm.startPrank(address(this));
        if (seed < type(uint).max / 100 * 80) skip(4 hours);

        address token0;
        address token1;
        uint24 fee;
        if (version == UniswapLiquidity.Version.V2) {
            IUniswapV2Pair pair = IUniswapV2Pair(poolAddr);
            token0 = pair.token0();
            token1 = pair.token1();
        }
        else if (version == UniswapLiquidity.Version.V3) {
            IUniswapV3Pool pool = IUniswapV3Pool(poolAddr);
            token0 = pool.token0();
            token1 = pool.token1();
            fee = pool.fee();
        }

        // Need to have some structure storing the owners of    
        address[] memory path = new address[](2);
        path[0] = seed < type(uint).max / 100 * 50 ? token0 : token1;
        path[1] = seed < type(uint).max / 100 * 50 ? token1 : token0;

        uint amountIn;
        address WETH = UniswapLiquidity.SWAP_ROUTER.WETH9();
        IWETH9 WETH9 = IWETH9(WETH);

        // Buy
        if (path[0] == WETH) {
            amountIn = _bound(amountSeed, 0.1 ether, 2 ether);
            WETH9.deposit{ value: amountIn }();
            WETH9.approve(address(UniswapLiquidity.SWAP_ROUTER), amountIn);
        }
        // Sell TODO: need to see if we have balance
        else {
            
            IMintableERC20 inToken = IMintableERC20(path[0]);
            amountIn = _bound(amountSeed, 0, inToken.balanceOf(address(this)));
            if (amountIn == 0) {
                amountIn = _bound(amountSeed, 10 ** inToken.decimals(), inToken.totalSupply() / 100);
                inToken.mint(amountIn);
            }
            inToken.approve(address(UniswapLiquidity.SWAP_ROUTER), amountIn);
        }

        if (path[0] == WETH) console.log("[Swap] BUY %s", amountIn.toFPString(18, vm));
        else console.log("[Swap] SELL %s", amountIn.toFPString(18, vm));

        if (version == UniswapLiquidity.Version.V2) {
            UniswapLiquidity.SWAP_ROUTER.swapExactTokensForTokens(
                amountIn, 
                0, 
                path, 
                address(this)
            );

            (uint r0, uint r1, ) = IUniswapV2Pair(poolAddr).getReserves();
            console.log("[Swap] r0: %s", r0.toFPString(18, vm));
            console.log("[Swap] r1: %s", r1.toFPString(18, vm));
            console.log("[Swap] K: %d", r0 * r1);
            console.log("[Swap] Price: %d", r1 * 10 ** 18 / r0);
            console.log("");
        }
        else if (version == UniswapLiquidity.Version.V3) {
            UniswapLiquidity.SWAP_ROUTER.exactInputSingle(IV3SwapRouter.ExactInputSingleParams({
                tokenIn: path[0],
                tokenOut: path[1],
                fee: fee,
                recipient: address(this),
                amountIn: amountIn,
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0 
            }));
        }
        vm.stopPrank();
    }

    // function test_multipleOwnerCollect()
    function test_multipleOwnerPosition() {
        vm.recordLogs();
        TestERC20 tokenA = new TestERC20();
        uint256 amountIn = _bound(seed, 0.1 ether, 70 ether);

        address pool = UniswapLiquidity.V2_FACTORY.getPair(address(tokenA), WETH);
        (uint256 id, uint256 amountIn0, uint256 amountIn1, ) = lVault.mint{ value: amountIn }(ILiquidityVault.MintParamsV2({
            tokenA: address(tokenA),
            tokenB: ILiquidityVault.ETH,
            permitA: NoPermit(),
            permitB: NoPermit(),
            amountA: tokenA.totalSupply(),
            amountB: amountIn,
            lockDuration: _bound(durationSeed, 0, ILiquidityVault.LOCK_FOREVER)
        }));

        Vm.Log[] memory logs = vm.getRecordedLogs();
        Vm.Log memory v2snapshotLog = logs[logs.length - 2];

        ILiquidityVault.LiquidityPoolSnapshot memory v2snapshot = SnapshotLogDecoder.decode(v2snapshotLog);
        assertEq(amountIn0, v2snapshot.amountIn0);
        assertEq(amountIn1, v2snapshot.amountIn1);

        (uint256 collectedFee0, uint256 collectedFee1) = lVault.collect(id, v2snapshot);

        Vm.Log[] memory logs = vm.getRecordedLogs();
        Vm.Log memory v2snapshotLog = logs[logs.length - 2];
        v2snapshot = LiquidityVault.decodeSnapshot(v2snapshotLog);

        (uint256 lpAmount0, uint256 lpAmount1) = UniswapLiquidity.amountsFromLiquidityV2(pool, v2snapshot.liquidity);
        assertEq(lpAmount0, v2snapshot.amountIn0);
        assertEq(lpAmount1, v2snapshot.amountIn1);
    }

    function test_tokenETHCollect(uint tokenBSeed, uint feeSeed, uint tradeSeed, uint32 lockTime) external {
        vm.skip(true);
        startHoax(msg.sender);
        vm.recordLogs();
        TestERC20 tokenAV2 = new TestERC20();

        uint tokenASupplyV2 = tokenAV2.totalSupply();
        uint tokenBSupply = _bound(tokenBSeed, 0.1 ether, 5 ether);

        tokenAV2.approve(address(lVault), tokenASupplyV2);

        lVault.mint{ value: tokenBSupply }(ILiquidityVault.MintParamsV2({
            tokenA: address(tokenAV2),
            tokenB: address(0),
            permitA: NoPermit(),
            permitB: NoPermit(),
            amountA: tokenASupplyV2,
            amountB: tokenBSupply,
            lockDuration: lockTime
        }));

        Vm.Log[] memory logs = vm.getRecordedLogs();
        Vm.Log memory v2snapshotLog = logs[logs.length - 2];
        ILiquidityVault.LiquidityPoolSnapshot memory v2snapshot = ILiquidityVault.LiquidityPoolSnapshot({
            pool: pool,
            amountIn0: uint(v2ProofLog.topics[2]),
            amountIn1: uint(v2ProofLog.topics[3]),
            liquidity: uint(v2ProofLog.topics[1])
        });



        address WETH = UniswapLiquidity.SWAP_ROUTER.WETH9();

        /*
            if no holders we should only buy 
        */
        (uint fee0, uint fee1) = lVault.collect(v2ID, v2Proof);
        logs = vm.getRecordedLogs();
        // TODO: the encoding of the log have changed
        v2ProofLog = logs[logs.length - 1];
        v2Proof = ILiquidityVault.LiquidityPoolSnapshot({
            pool: UniswapLiquidity.V2_FACTORY.getPair(address(tokenAV2), WETH),
            initAmount0: uint(v2ProofLog.topics[2]),
            initAmount1: uint(v2ProofLog.topics[3]),
            liquidity: uint(v2ProofLog.topics[1])
        });

        for (uint i; i < _bound(tradeSeed, 0, type(uint8).max); i++) {
            uint a;
            unchecked { a = tradeSeed + i; }
            uint psuedoRandom0 = uint(keccak256(abi.encodePacked(block.timestamp, a, msg.sender))); 
            uint s;
            unchecked { s = (tradeSeed + i) * (tradeSeed + i); }
            uint psuedoRandom1 = uint(keccak256(abi.encodePacked(block.timestamp, s, msg.sender))); 
            swap(
                v2Proof.pool,
                UniswapLiquidity.Version.V2,
                psuedoRandom0,
                psuedoRandom1
            );

            if (psuedoRandom1 < type(uint).max / 100 * 40) {
                vm.startPrank(msg.sender);
                lVault.collect(v2ID, v2Proof);
                // After collect you need to test that the same liquidity that you added you can get back

                logs = vm.getRecordedLogs();
                v2ProofLog = logs[logs.length - 1];
                v2Proof = ILiquidityVault.LiquidityPoolSnapshot({
                    pool: UniswapLiquidity.V2_FACTORY.getPair(address(tokenAV2), address(UniswapLiquidity.SWAP_ROUTER.WETH9())),
                    initAmount0: uint(v2ProofLog.topics[2]),
                    initAmount1: uint(v2ProofLog.topics[3]),
                    liquidity: uint(v2ProofLog.topics[1])
                });
                vm.stopPrank();
            }
        }

        // V3
        vm.startPrank(msg.sender);

        TestERC20 tokenAV3 = new TestERC20();
        console.log("v3 token address: %s", address(tokenAV3));
        uint tokenASupplyV3 = tokenAV3.totalSupply();

        tokenAV3.approve(address(lVault), tokenASupplyV3);

        uint24 fee = UniswapLiquidity.FEE_TIERS()[_bound(feeSeed, 0, 2)];
        (int24 lowerTick, int24 upperTick) = UniswapLiquidity.maxTickBoundary(fee);
        lVault.mint{ value: tokenBSupply }(ILiquidityVault.MintConfig({
            version: UniswapLiquidity.Version.V3,
            tokenA: address(tokenAV3),
            tokenB: address(0),
            permitA: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            permitB: Permit({ enable: false, deadline: 0, r: 0, s: 0, v: 0 }),
            amountA: tokenASupplyV3,
            amountB: tokenBSupply,
            requiredA: 0,
            requiredB: 0, 
            fee: fee,
            tickLower: lowerTick,
            tickUpper: upperTick,
            lockDuration: lockTime
        }));


        logs = vm.getRecordedLogs();
        transferLog = logs[logs.length - 1];

        uint v3ID = uint(transferLog.topics[3]);
        console.log("v3ID: %d", v3ID);



        v2Proof = ILiquidityVault.LiquidityPoolSnapshot(address(0), 0, 0, 0);

        lVault.collect(v3ID, v2Proof);
        lVault.collect(v3ID, v2Proof);
        lVault.collect(v3ID, v2Proof);

         for (uint i; i < _bound(tradeSeed, 0, type(uint8).max); i++) {
            uint a;
            unchecked { a = tradeSeed + i; }
            uint psuedoRandom0 = uint(keccak256(abi.encodePacked(block.timestamp, a, msg.sender))); 
            uint s;
            unchecked { s = (tradeSeed + i) * (tradeSeed + i); }
            uint psuedoRandom1 = uint(keccak256(abi.encodePacked(block.timestamp, s, msg.sender))); 
            
            (, , address token0, address token1, , , , , , , , ) = UniswapLiquidity.V3_LP_MANAGER.positions(uint256(lVault.lpIdentifierForVault(v3ID)));
            swap(
                UniswapLiquidity.getV3PoolAddress(token0, token1, fee),
                UniswapLiquidity.Version.V3,
                psuedoRandom0,
                psuedoRandom1
            );

            if (psuedoRandom1 < type(uint).max / 100 * 40) {
                vm.startPrank(msg.sender);
                lVault.collect(v3ID, v2Proof);

                vm.stopPrank();
            }
        }

    }

}